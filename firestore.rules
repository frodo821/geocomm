rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
  	function isValidMessage(data, uid) {
      return
        uid != null &&
        data.keys().hasOnly([
        'at', 'user_id', 'channel_a', 'channel_b', 'channel_c',
        'content', 'geohash', 'reply_to', 'sent_at', 'embeddings']) &&
        'at' in data && data.at is latlng &&
        'user_id' in data && data.user_id is string && data.user_id == uid &&
        'channel_a' in data && data.channel_a is number &&
        'channel_b' in data && data.channel_b is number &&
        'channel_c' in data && data.channel_c is number &&
        'content' in data && data.content is string &&
        'geohash' in data && data.geohash is string &&
        'reply_to' in data && (data.reply_to is string || data.reply_to == null) &&
        'sent_at' in data && data.sent_at is timestamp &&
        'embeddings' in data && data.embeddings is list;
  	}
    
    function isValidUserData(data) {
    	return data.keys().hasOnly(['created_at', 'display_name']) &&
      			 data.keys().hasAll(['created_at', 'display_name']);
    }
    
    function isAllowedUpdateUserData(original, updating) {
    	return updating.diff(original).affectedKeys().hasOnly(['display_name']);
    }

    match /messages/{message_id} {
    	allow read: if true;
      allow update: if false;
      allow create: if isValidMessage(request.resource.data, request.auth.uid);
      allow delete: if resource.data.user_id == request.auth.uid;
    }

    match /users {
      allow write: if false;
      allow read: if true;

      match /{userId} {
        allow create: if request.auth.uid != null && isValidUserData(request.resource.data);
        allow update: if request.auth.uid == userId &&
                         isAllowedUpdateUserData(resource.data, request.resource.data);
        allow read: if true;
      }
    }
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
